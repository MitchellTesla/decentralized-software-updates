\section{Update Logic}
%\nnote{
%Activation Phase
%the activation phase is not a re-approval phase, it is just there to guard against chain split.s
%It is not relevant to UPs that dont impact consensus (adoption threshold = 0%)
%For those that do impact, adoption threshold = the honest stake threshold assumption of the consensus protocol. We make the assumption that if a UP is approved then all honest stake will eventually upgrade.
%To mitigate risk of chain split by accident (activation too early), we propose the concept of the activation lag.
%}
%\paragraph{What is Update Logic}
%Update Logic = Metadata-Driven Software Updates
We have pointed out many times that software updates are not all the same. There are many different perspectives for viewing SUs, which call for a specialized \emph{software update policy}. Software updates can be distinguished by the following dimensions:
\begin{itemize}
\item Reason of change (a bug-fix, or a security-fix versus a change request, or a new feature request).
\item Priority of change (e.g., high/medium/low).
\item Size of change (e.g., man-effort required to be implemented).
\item Impact of change (e.g., whether it impacts the consensus protocol, or not).
\item Type of protocol change (hard/soft/velvet fork)
\item Platform-specific change (Linux, Windows MacOS etc.)
\end{itemize}
To this end, we propose a \emph{software update logic} that is \emph{metadata driven}. A \say{logic} that can distinguish one SU from another and apply the appropriate update policy. In the section, we describe our proposal for achieving such a decentralized metadata-driven, software update mechanism.

\subsection{Software Update Metadata} 
A software update is inherently accompanied by meta-information that describes the update and sets it into the appropriate context. Therefore, we could say that every software update comprises a rich set of update meta-data that ultimately should drive the whole upgrade process. We distinguish several categories of metadata that result to a holistic view of a software update. The list of metadata categories presented next is indicative and aims at justifying the concept, therefore it is by no means complete, or restrictive in any way:
%\begin{itemize}
%\item
\paragraph{Basic information.}The software update metadata should provide basic information about the software update, such as its title and a basic description. Also, the metadata should include the unique id of the SU, which can be the content hash of the SU and also the \emph{category tag} that will enable delegation for specialization, as we have described above. Other basic information include, the author of the SU, version information and a link pointing to the storage area, where the software update is stored, as well as a link to the metadata itself. Finally, since in our proposal, we distinguish software updates from SIPs to UPs, the basic metadata information should include a flag to separate one from the other.
\paragraph{Justification.} This is a very important part of the metadata of a software update, especially if this is a SIP. It is the information, with which the author of the update will try to convince the rest of the stakeholders on the merit of the proposed software update. Missing information in this part, or unclear justification statements, might cause the rejection of a proposal. The reason, the scope and the expected benefits of a software update must be clearly stated in this part.
\paragraph{Urgency.} This is where the priority requirement of a software update must be declared. If it is a bug-fix for example, then it should specify a severity level, in order to declare the urgency for deployment. Similarly, if it is a change request, a priority specification, will help the stakeholders prioritize the demand.
\paragraph{Consensus impact.} There are software updates that impact the consensus protocol and others that do not. For the former, it is important to declare the type of the change. If the validation rules of the protocol become less restrictive, then this is a \emph{hard fork} type of change. In this case, non-upgraded nodes reject the new type of blocks and thus there is a significant risk for a chain split. If the validation rules become more restrictive, then this is called a \emph{soft fork} type of change. In this case, the non-upgraded nodes accept the new type of blocks but the blocks generated buy these nodes are not accepted by the upgraded nodes. So, if the old nodes do not eventually upgrade, then they can not continue to issue new blocks. Finally, if the new validation rules are neither more restrictive, nor less restrictive, then we have a \emph{velvet fork} \cite{velvet}. This type of change does not entail the risk of a chain split. Naturally, the type of change is really important, because it signifies the risk for a \emph{chain split}. For example, a hard fork type of change entails much more risk for a chain split, in the case of nodes failing to upgrade on time, than a soft fork, or a velvet fork (which has no risk at all).
\paragraph{Implementation.} Next comes meta-information on the implementation of the software update. Examples could be if this software update entails code development, or if it is a parameter change. For the latter, a distinction could be made between static and dynamic parameter changes. Essentially, dynamic parameter changes are \say{code-less} software updates - no deployment of new code is required. An explicit list of protocol parameters affected by the software update must be provided. This will be also exploited for the conflict resolution between software updates, mentioned below. Other aspects of the implementation have to do with the size and the complexity of a software update. Typically an estimation of the required man-effort for its implementation could be included.
\paragraph{Deployment.} The deployment of a software update is really critical, especially for those updates that impact the consensus protocol. This is because a lack of synchronization at the deployment phase might result into a \emph{chain split by accident}. This part of the metadata comprises instructions on the deployment process, maybe deployment scripts, or declarative statements of the deployment process (if some automated software provisioning tool is used, e.g., ansible playbooks). Moreover, an estimation of the size of the deployment (in terms of man-effort required), would help to calculate parameters, such as the \emph{activation lag} described later on.
\paragraph{Rollback.} Symmetrically to the deployment, the metadata must include information for an un-install process, in the case of a problem. The type of information provided is similar to the deployment category.
\paragraph{Update constraints.} Software updates do not live in vacuum. They are strongly related to one another. In fact, there exist dependencies between software updates that if are not respected, then the upgrade will fail. We call all the dependencies and the conflicts between software updates \emph{update constraints}. It is very crucial to clearly define the update constraints of a software update in its metadata. This will illustrate how feasible is a specific software update. For example, a dependency of a SU on another SU, which has not been implemented yet is a clear indication of non-feasibility. Also, if two candidate software updates both change the value of the same protocol parameter, then they are in direct conflict and a resolution is due.
\paragraph{Update prerequisites.} In this part we define other prerequisites apart from the ones that have to do with other software updates that we have discussed before and therefore we can consider them as prerequisites from \say{external} factors. For example, platform requirements, or specific hardware requirements, in order for a software update to be applied successfully, should be mentioned in this section of the metadata.
\paragraph{Budget information.} Last but not least, comes the budget information. This is extremely useful information, especially if the update system is backed up by a treasury system \cite{treasury} that will assume the funding of the implementation of the software update.
%\end{itemize}

We have described different aspects of meta-information that could accompany a software update. The purpose was not to propose a complete list of metadata but rather to point out how important is the software update mechanism to be metadata driven. To this end, in the following subsections, we provide examples of exploitation of software update metadata in the phase of activation.


%\nnote{categories of metadata:
%- basic info (name, description, content hash, author description, version info, url, Category tag)
%- Justification of change (bug-fix, security-fix, CR, benefits from change etc.
%- Urgency of change (priority, level of severity)
%- Consensus impact (hard/soft/velvet/no-impact
%- implementation (method: dynamic/static parameter change, code development, size estimate: man-effort)
%- Change size (man-effort estimated)
%- Deployment (complexity man-effort estimated, instructions, ansible playbook)
%- Uninstall (instructions, ansible playbook)
%- Budget info
%- Update Constraints (dependencies to other SUs, prerequisites, conflicts with other SUs)  
%- Update prerequisites (Platform, HW requirements)}

%We need to define the set of update metadata that we need to maintain, in order to implement various \emph{update policies}, achieve conflict resolution, respect update dependencies and in general support the full scope of the Updating Process. These metadata will be included in the Update Proposal (see the Update Manifest below)

\subsection{Update Policies} 
An update policy is a way to customize the activation speed of a SU based on the type of the SU, which is deduced by the SU's metadata. We want to follow a metadata-driven activation approach. 
An update policy can be enabled by two things:
A) Delegation to expert pools
B) adoption threshold (activation phase) and activation lag (activation phase)
Activation lag is determined by
Deployment complexity
Soft/Hard fork type of change

\subsubsection{The Adoption Threshold}

\paragraph{Activation Phase} 
the activation phase is not a re-approval phase, it is just there to guard against chain split.s

It is not relevant to UPs that dont impact consensus (adoption threshold = 0\%)
For those that do impact, adoption threshold = the honest stake threshold assumption of the consensus protocol. We make the assumption that if a UP is approved then all honest stake will eventually upgrade.

\subsubsection{The Activation Lag}
To mitigate risk of chain split by accident (activation too early), we propose the concept of the \emph{activation lag}.


%\subsection{The Activation Phase Revisited}


\subsection{Update Constraints}

\subsubsection{Dependencies}
How do we impose respect for update dependencies, so that the system reaches a consistent state? 
\nnote{Maybe we could use the version\_from field from the metadata for this purpose. An Update Proposal cannot be applied if the version requirement that it poses (version\_from) is not the current version}


\subsubsection{Conflict Resolution}
How do we ensure that multiple concurrent requests for updates are handled simultaneously in a way that
\begin{itemize}
\item conflicts are resolved and the adopted updates are consistent, 
\item so that no contradictory updates are to be deployed at the same time
\item Community splits over controversial updates are avoided
\end{itemize}


\subsection{Rollbacks}
How can we smoothly rollback an update, in the case of a problem?


%\subsubsection*{Update Policies per type of updates -- old stuff}
%An \emph{Update Policy} is defined as the pair \emph{(Speed of Activation, Method of Deployment)}. We need to differentiate the speed of deployment and the method of deployment based on: a) the type of change (bug -fix or change request), b) the part of the system that is affected by the change (consensus rules impact, or only software impact), c) the urgency of the change (severity level)
%and d) soft vs. hard forks
%
%\todo{Nikos: We have 3 levels of speed: high, medium and low. What are our different deployment methods?}
%
%\begin{itemize}
%\item How do we discriminate between different types of updates (e.g., software vs. protocol, bug-fix vs. change request)
%\item We need to provide a different deployment path for each Type of Update. For example, critical hot-fixes might need to bypass some of the governance steps.
%\item We need to incorporate into our update logic the notions of bug Severity and ''Required Speed of Deployment''
%\end{itemize}
%
%Also, deployment/activation time must vary according to the type of change. We see the following ''change categories'':
%\begin{itemize}
%\item Bug-fix vs. Change Request
%\item Consensus Protocol impact vs. No Impact
%\item High severity vs. Low severity
%\end{itemize}

