\subsection{Candidate Protocols for PoS Ledgers}

Let $\ledger_1$ be the ledger that the parties are running with assumption $\asmp_1$, common-prefix parameter $k_1$ 
and  liveness parameter $s_1$. 
We now consider a new ledger $\ledger_2$ with assumption $\asmp_2$ and common-prefix parameter $k_2$ and  liveness parameter $s_2$.
In the description of our update protocol we assume that there is a time $t^\upd$ such that $\asmp_2[t]$ holds for all $t\geq t^\upd$.\footnote{We could require $\asmp_2$ to
hold only for bounded interval of time and our protocol would still work if this interval is large enough.}
We also assume that the parties in $\activep$ knows an index $j$ such that when the $j$-th block is added to the state of $\ledger_1$ then $\asmp_2$ holds. 
To ensure that $\asmp_2$ actually holds and that the parties can agree on the index $j$ we use the approach proposed in Sec.~\ref{se:u}. 
\mnote{say more on that.} 

We denote our update protocol with $\Pi$. In this, each honest party $P_i\in\activep$ at time $t^\upd$ executes the following steps

\begin{enumerate}
	\item Upon receiving the input $(\activate, \cdot)$ wait until the $j$-th block of $\ledger_1$ becomes stable (i.e., wait until $B_{j}$ becomes part of $\ledger_1^{P_i}[t]$ 
	for all honest $P\in\activep$) and let $t^\upd$ be this time.
	\item When the $(j+k)$-th block $B_{j+k}$ appears in $\ledger_1^{P_i}[t]$ for some $t\geq t^\upd$ then 
	start running $\ledger_2$ using the $B_{j+k}$ as the genesis block.
	\item Run $\ledger_1$ and $\ledger_2$ in parallel until $B_{j+k}$ becomes part of $\ledger_2^{P_i}[t]$ 
	for each honest $P\in\activep$.
	\item Stop running $\ledger_1$.
\end{enumerate}



\begin{theorem}
$\Pi$ is a $(\Delta_1,\Delta_2)$-secure update system with $\Delta_1=s_1 k_1$ and $\Delta_2=s_1 k_1 + s_2 k_2$.
\end{theorem}

\begin{proof}
By assumption we have that $\asmp_2[t]=1$ for all $t\geq t^\upd$. From the description of $\Pi$ 
we can claim that $t^\upd \leq k_1 s_1=\Delta_1$.
From the moment where $\asmp_2$ becomes true the update process takes $\Delta_2=s_1 k_1 + s_2 k_2$  times slots more to complete the update.
This because the parties need to wait that $k_1$ blocks are generated in $\ledger_1$ and that $k_2$ blocks are generated in $\ledger_2$. 
That is, the parties need to wait that the $(j+k_1)$-th block is stable in $\ledger_1$ (i.e., 
it appears in $\ledger_1^P[t]$ for each honest $P\in\activep$) and the \emph{genesis block} of $\ledger_2$ (that corresponds to the block $B_{j+k}$ of $\ledger_1$) appears 
in $\ledger_2^P[t]$ for each honest $P\in\activep$. Given that to stabilize a block in $\ledger_1$ takes time (at most) $s_1$ and that to stabilize
each block in $\ledger_2$ takes time (at most) $s_1$ then the updated process takes time $\Delta_2=s_1 k_1 + s_2 k_2$.
We observe that in the moment the block $B_{j+k}$ become available to honest parties in $\activep$, these parties start running $\ledger_2$ while $\asmp_2$ holds.
That is, the honest parties try to extend $B_{j+k}$ using both $\ledger_1$ and $\ledger_2$. Since we are assuming that a block of $\ledger_1$ is 
a valid candidate genesis block for $\ledger_2$ and $\asmp_2$ holds then we claim that $\ledger_2$ is secure and has as a prefix all the blocks $\ledger_1$ up to
$B_{j+k}$. We note that the parties in $\activep$ need to run $\ledger_1$ until the $B_{j+k}$ become stable in $\ledger_2$ otherwise. That is, we need $\asmp_1$ to
holds until the end of the update process otherwise ad adversary could subvert $\ledger_1$ thus changing the $j+k$-th block of $\ledger_1$ (which would not be stale
since the consistency property would not hold).

\end{proof}
