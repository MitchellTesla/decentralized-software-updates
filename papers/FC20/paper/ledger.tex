
\subsection{The blockchain abstraction}\label{se:bcabstraction}

Following~\cite{treasury}, we abstract the following concepts.
\begin{itemize}
	\item Coin. We assume the underlying blockchain platform has the notion of
Coins or its equivalent. Each coin can be spent only once, and all the value of
coin must be consumed. Each coin consists of the following
4 attributes:
	\begin{itemize}
		\item[-]Coin ID: it is an implicit attribute, and every coin has a unique ID that
can be used to identify the coin.
		\item[-] Value: It contains the value of the coin.
		\item[-]Cond: It contains the conditions under which the coin can be spent.
		\item[-] Payload: It is used to store any non-transactional data.
	\end{itemize}
	\item Address: conventionally, an
		address is merely a public key, $\pk$, or hash of a public key, $h(\pk)$. To create
coins associated with the address, the spending condition of the coin should be
defined as a valid signature under the corresponding public key $\pk$ of the address.
In this work, we define an address as a generic representation of some spending
condition. Using the recipient address, a sender is able to create a new coin
whose spending condition is the one that the recipient intended; therefore, the
recipient may spend the coin later.
	\item Transaction: Each transaction takes one or more (unspent) coins, denoted
		as $\{\inp\}_{i\in [n]}$, as input, and it outputs one or more (new) coins, denoted as
 $\{\out\}_{j\in [m]}$. Except special transactions, the following condition holds:

		$$\sum_{i=1}^n{\inp_i.\Value} \geq \sum_{j=1}^m {\out_j.\Value}$$
		and the difference is interpreted as transaction fee.
		The transaction has a Verification data field that contains the necessary verification data to satisfy all the spending conditions of the input coins $\{\inp\}_{i\inp[n]}$. In addition, each transaction also has a Payload field that can be used to store any non-transactional data. We denote a transaction as $\tx(A; B; C)$, where $A$ is the set
of input coins, $B$ is the set of output coins, and $C$ is the Payload field. Note that
the verification data is not explicitly described for simplicity.
\end{itemize}

\subsection{Ledger Consensus}
Ledger consensus (a.k.a. ``Nakamoto consensus'') is the problem where a set of servers
(or nodes) operate continuously accepting inputs
that are called transactions and incorporate them in a public data 
structure called the {\em ledger}. 
A ledger (denoted in calligraphic-face, e.g. $\ledger$) is a mechanism for maintaining a sequence of transactions, often
stored in the form of a blockchain. In this paper, we slightly abuse the language by letting $\ledger$ (without further
qualifiers) interchangeably refer to the algorithms used to maintain the sequence, and all the views of the
participants of the state of these algorithms when being executed. For example, the (existing) ledger Bitcoin
consists of the set of all transactions that ever took place in the Bitcoin network, the current UTXO set, as
well as the local views of all the participants.
In contrast, we call a ledger state a concrete sequence of transactions $\tx_1,\tx_2,\dots$ stored in the stable
part of a ledger $\ledger$, typically as viewed by a particular party. Hence, in every blockchain-based ledger $\ledger$,
every fixed chain $C$ defines a concrete ledger state by applying the interpretation rules given as a part of the
description of $L$ (for example, the ledger state is obtained from the blockchain by dropping the last $k$ blocks
and serializing the transactions in the remaining blocks). We denote by $P^\ledger[t]$
the ledger state of a ledger $\ledger$ as viewed by a party $P$ at the beginning of a time slot $t$.
% and by $\hat P^\ledger[t]$ the complete state of the ledger (at time $t$) including all pending transactions that are not stable yet. 


For two ledger states (or, more generally, any sequences), we denote by $\preceq$ the prefix relation.
Recall the definition of secure ledger protocol given in~\cite{sok}.



%Clients are able to read the ledger
%and submit transactions to be
%added to it.
%The purpose of ledger consensus is to provide a unique
%view to the ledger for the clients. 
%The properties that a ledger consensus protocol must satisfy are as follows:

\begin{definition}\label{de:ledger} A ledger protocol $\ledger$ is secure if it enjoys the following two properties.
\begin{itemize}

\item {\em Consistency:} This property mandates that if a client queries
an honest node's ledger at round $t_1$  
and receives the response $\mc{L}_1$, 
then a client querying an honest node's ledger at round $t_2\geq t_1 $
 receives a response $\mc{L}_2$ that satisfies $\mc{L}_1 \preceq \mc{L}_2$, 
where $\preceq$ denotes the standard prefix operation. 

\item {\em Liveness:} If a transaction $tx$ is given as input to all honest
nodes continuously for a certain number of rounds denoted by $u$, 
and a client queries any honest node's ledger
after these $u$ rounds, then the node responds with a value
$\mc{L}$ that includes $tx$.

\end{itemize}

\end{definition}

\subsection{Defining Secure Activations}
We consider a setting where a set of parties run a protocol maintaining a $\ledger_1$. Following~\cite{sidechain} we denote by $\asmp_i$
with $i\in[n]$ the security assumption required by a ledger $\ledger_i$. That is, if the assumption holds then ledger is secure under the Definition~\ref{de:ledger}.
Formally, $\asmp_i$ is a sequence of events $\asmp_i[t]$ for each time slot $t$ that can assume value $1$, if the assumption is satisfied, $0$ otherwise.

%Without loss of generality we assume that $\asmp_i$ are monotone in the sense that once violated, they cannot become true again. Formally, 
%$\asmp_i$ is a sequence of events $\asmp_i[t]$ for each time slot $t$ that satisfy $\neg \asmp_i[t] \rightarrow \neg \asmp_i[t+1]$ for all $t$.
There is an a priori unlimited number of (types of) assets, each asset representing e.g. a different cryptocurrency. We allow specific rules of behavior for each asset (called validity languages), and each asset behaves according to these rules on each of the ledgers where it is present.

Let $\ledger_1$ be the ledger that the parties are running with assumption $\asmp_1$. We consider a new ledger $\ledger_2$ with assumption $\asmp_2$.
In the model that we consider in this paper each party that is running $\ledger_1$ could receive the input $(\activate, \ledger_2)$. A party receiving this command starts the \emph{activation process}
in order to start running $\ledger_2$ (and maybe stop running $\ledger_1$). Let $t_P$ denote the time in which 
the party $P$ receives the activation command and let $\activep$ be the set of parties that received the activation command. Without loss of generality, let $P_1$ be the first party to receive the activation command (note that $t_{P_1}\leq t_{P_i}$ for all $P_i\in\activep$).
%We note that if a set of parties $\parties$ is such that the assumption $\asmp_2$ holds (e.g. if enough honest parties are willing to maintain $\ledger_2$), then $\ledger_2$ is
%secure.

Let $t$ be the time at which one of the parties that is running $\ledger_1$ is activated. Informally, a secure activation process guarantees that if the number of parties that are willing to run $\ledger_2$ (i.e. the number of active parties)  
are such that $\asmp_2[t']=1$ for some $t'>t$, then at time $t'+\Delta$ the state of $\ledger_2$ corresponds to the state of $\ledger_1$ at time $t$. 
The above implies that $\ledger_2$ extends $\ledger_1$ and that $\ledger_2$ is secure (i.e. enjoys consistent and liveness).
In a nutshell, a secure activation process guarantees that the state of the old ledger is moved into the new ledger, and that the new ledger is secure.
We now give a more formal definition.

\begin{definition}[Activation Process]
 We say that an activation process is secure if the following condition is satisfied:

If $\activep$ is such that $\asmp_2[t]=1$ for all $t\in [t_{P_1}+\Delta_1, t_{P_1}+\Delta_2]$ with $\Delta_1,\Delta_2\in\mathbb{N}$
	and $\asmp_1[t']=1$ for all $t' \leq t_{P_1}+\Delta_1$, then the state of $\ledger_2$ at some time $T\in [t_{P_1}+\Delta_1, t_{P_1}+\Delta_1+\Delta_2]$ is such that $\ledger^\star=\ledger_2$
	where $  P_i^{\ledger_1}[t_{P_i}] \preceq \ledger^\star$ for some $P_i\in\activep$.  
\end{definition}



%A commuting process is secure if there exists a time $t=$ where $\asmp_2[t]=1$ and the state of $\ledger_2$ at time $t$ is  $\ledger^\star=\ledger_2$ 	where $  %P_i^{\ledger_1}[t_{P_i}] \preceq \ledger^\star$ for some $P_i\in\activep$.


