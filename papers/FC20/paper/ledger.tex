\subsection{Ledger Consensus}
Ledger consensus (a.k.a. ``Nakamoto consensus'') is the problem where a set of servers
(or nodes) operate continuously accepting inputs
that are called transactions and incorporate them in a public data 
structure called the {\em ledger}. Clients are able to read the ledger
and submit transactions to be
added to it.
The purpose of ledger consensus is to provide a unique
view to the ledger for the clients. 

The properties that a ledger consensus protocol must satisfy are as follows:

\begin{itemize}

\item {\em Consistency:} This property mandates that if a client queries
an honest node's ledger at round $t_1$  
and receives the response $\mc{L}_1$, 
then a client querying an honest node's ledger at round $t_2\geq t_1 $
 receives a response $\mc{L}_2$ that satisfies $\mc{L}_1 \preceq \mc{L}_2$, 
where $\preceq$ denotes the standard prefix operation. 

\item {\em Liveness:} If a transaction $tx$ is given as input to all honest
nodes continuously for a certain number of rounds denoted by $u$, 
and a client queries any honest node's ledger
after these $u$ rounds, then the node responds with a value
$\mc{L}$ that includes $tx$.

\end{itemize}


\subsection{The blockchain abstraction}

Following~\cite{treasury}, we abstract the following concepts.
\begin{itemize}
	\item Coin. We assume the underlying blockchain platform has the notion of
Coins or its equivalent. Each coin can be spent only once, and all the value of
coin must be consumed. Each coin consists of the following
4 attributes:
	\begin{itemize}
		\item[-]Coin ID: it is an implicit attribute, and every coin has a unique ID that
can be used to identify the coin.
		\item[-] Value: It contains the value of the coin.
		\item[-]Cond: It contains the conditions under which the coin can be spent.
		\item[-] Payload: It is used to store any non-transactional data.
	\end{itemize}
	\item Address: conventionally, an
		address is merely a public key, $\pk$, or hash of a public key, $h(\pk)$. To create
coins associated with the address, the spending condition of the coin should be
defined as a valid signature under the corresponding public key $\pk$ of the address.
In this work, we define an address as a generic representation of some spending
condition. Using the recipient address, a sender is able to create a new coin
whose spending condition is the one that the recipient intended; therefore, the
recipient may spend the coin later.
	\item Transaction: Each transaction takes one or more (unspent) coins, denoted
		as $\{\inp\}_{i\in [n]}$, as input, and it outputs one or more (new) coins, denoted as
 $\{\out\}_{j\in [m]}$. Except special transactions, the following condition holds:

		$$\sum_{i=1}^n{\inp_i.\Value} \geq \sum_{j=1}^m {\out_j.\Value}$$
		and the difference is interpreted as transaction fee.
		The transaction has a Verification data field that contains the necessary verification data to satisfy all the spending conditions of the input coins $\{\inp\}_{i\inp[n]}$. In addition, each transaction also has a Payload field that can be used to store any non-transactional data. We denote a transaction as $\tx(A; B; C)$, where $A$ is the set
of input coins, $B$ is the set of output coins, and $C$ is the Payload field. Note that
the verification data is not explicitly described for simplicity.
\end{itemize}


