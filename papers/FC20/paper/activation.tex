\section{Defining a Secure Update System} \label{secureupdate}
We have seen that upon the approval of a UP, users start installing the software update (i.e., upgrade) and wait for the activation of the changes. We call the time period from the approval of a UP until the actual activation of the changes in the blockchain system as the \emph{activation lag}. In order, to enable a fast and flexible software updating mechanism, we should minimize the activation lag, which is in turn determined by the \emph{adoption threshold}. These are the topics to be discussed in this section.

\subsection{The Activation of Changes}
%In the lifecycle section, we have described how a software update, after being voted as a SIP, it is submitted again during the approval phase in the form of a UP (source code bundled with metadata), in order to be approved. We make the assumption 
In our protocol, we assume that if a UP is approved, then all (honest) stake will eventually upgrade. However, if we want to have a minimum activation lag, then we cannot wait until all the stake upgrades, to kick-off activation. What is the minimum necessary percent of stake to have upgraded, before the actual activation of the change takes place, in order to avoid a chain split? The \emph{adoption threshold} is used in the activation phase and corresponds exactly to the minimum percent of stake that is necessary to have signaled activation readiness, before the actual activation of a software update takes place. It is essentially a synchronization point that ensures that a sufficient percent of stake has upgraded and thus it is safe to actually activate the changes. It is therefore a guard against chain splits. Please note that the adoption threshold is only relevant for software updates that impact the consensus protocol. For all other software updates the activation can take place immediately after the upgrade.

Let us assume that the adoption threshold of our software updates protocol is called $\tau_A$. %In order to enable update policies, we need to be able to adjust $\tau_A$ based on each software update's metadata. 
What would be the appropriate values for $\tau_A$? Take into account that by adjusting the value of $\tau_A$, we risk to cause a chain split for two distinct reasons: a) A too-low value of $\tau_A$ might result to a \emph{too-early activation}, which will result to the partition of the honest stake in two and a potential chain split\footnote{A partition of the honest stake also undermines the security of the underlying consensus protocol which assumes a minimum threshold $x$ of honest stake.}  and b) a too-high value of $\tau_A$ might result to a \emph{too-late activation}, giving the opportunity to adversaries to block an activation by refusing to signal. We call this a \emph{Denial of Activation} attack. %Clearly the former is a safety problem, while the latter is a security problem. 
What is the allowable range of values for $\tau_A$, in order to mitigate these risks?

In order to avoid both of the two problems described above, the adoption threshold $\tau_A$ should take values in the range $x \leq \tau_A \leq h_a$, where $x$ is the theoretical honest stake threshold of the underlying consensus protocol and $h_a$ is the \emph{actual} percent of honest stake (of course $h_a \geq x$). In addition, we assume that the honest stake that has signaled, when the threshold is met, is at least $x$ ($S_{honest} \geq x$) , i.e., at least equal to the honest stake threshold of the consensus protocol. The rationale of this result is explained in the appendix \ref{appxadoption}, due to space limitations.

A possible attack in the case where $x \leq \tau_A \leq h_a$ is the adversary to hurry to signal for a software update, so that the threshold $\tau_A$ is met, without (at least) $x$ honest stake to have enough time to complete the upgrade (i.e., $S_{honest} < x$). Thus a too-early activation will take place and the honest stake will be partitioned for some time, risking a chain split and also running the consensus protocol without the $x$ honest stake assumption.

Intuitively, in order to prevent this type of attack, we need to give more time to honest stake to upgrade, since we have assumed that all honest stake will eventually upgrade. This is especially true for difficult to deploy software updates, or hard fork type of changes, where the risk of a chain split is greater. A high value of $\tau_A$ would help towards this end, which means that our update policy, would ideally adjust the adoption threshold close to $h_a$ (i.e., to the actual percent of honest stake). Of course, we do not know $h_a$ exactly and we should base it on some sort of estimation. What if we could delay the activation of changes, even though the $\tau_A$ threshold has been met? This is the topic of the next subsection. 

\subsection{Ledger Consensus}
Ledger consensus (a.k.a. ``Nakamoto consensus'') is the problem where a set of servers
(or nodes) operate continuously accepting inputs
that are called transactions and incorporate them in a public data 
structure called the {\em ledger}. 
A ledger (denoted in calligraphic-face, e.g. $\ledger$) is a mechanism for maintaining a sequence of transactions, often
stored in the form of a blockchain (cf. appendix \ref{se:bcabstraction}). In this paper, we slightly abuse the language by letting $\ledger$ (without further
qualifiers) interchangeably refer to the algorithms used to maintain the sequence, and all the views of the
participants of the state of these algorithms when being executed. For example, the (existing) ledger Bitcoin
consists of the set of all transactions that ever took place in the Bitcoin network, the current UTXO set, as
well as the local views of all the participants.
In contrast, we call a ledger state a concrete sequence of transactions $\tx_1,\tx_2,\dots$ stored in the stable
part of a ledger $\ledger$, typically as viewed by a particular party. Hence, in every blockchain-based ledger $\ledger$,
every fixed chain $C$ defines a concrete ledger state by applying the interpretation rules given as a part of the
description of $\ledger$ %\nnote{shouldn't this be a calligraphic L?} 
(for example, the ledger state is obtained from the blockchain by dropping the last $k$ blocks
and serializing the transactions in the remaining blocks). We denote by $P^\ledger[t]$
the ledger state of a ledger $\ledger$ as viewed by a party $P$ at the beginning of a time slot $t$.
% and by $\hat P^\ledger[t]$ the complete state of the ledger (at time $t$) including all pending transactions that are not stable yet. 


For two ledger states (or, more generally, any sequences), we denote by $\preceq$ the prefix relation.
Recall the definition of secure ledger protocol given in~\cite{sok}.



%Clients are able to read the ledger
%and submit transactions to be
%added to it.
%The purpose of ledger consensus is to provide a unique
%view to the ledger for the clients. 
%The properties that a ledger consensus protocol must satisfy are as follows:

\begin{definition}\label{de:ledger} A ledger protocol $\ledger$ is secure if it enjoys the following two properties.
\begin{itemize}

\item {\em Consistency:} This property mandates that if a client queries
an honest node's ledger at round $t_1$  
and receives the response $\mc{L}_1$, 
then a client querying an honest node's ledger at round $t_2\geq t_1 $
 receives a response $\mc{L}_2$ that satisfies $\mc{L}_1 \preceq \mc{L}_2$, 
where $\preceq$ denotes the standard prefix operation. 

\item {\em Liveness:} If a transaction $tx$ is given as input to all honest
nodes continuously for a certain number of rounds denoted by $u$, 
and a client queries any honest node's ledger
after these $u$ rounds, then the node responds with a value
$\mc{L}$ that includes $tx$.

\end{itemize}

\end{definition}

\subsection{Defining Secure Activations}
We consider a setting where a set of parties run a protocol maintaining a ledger $\ledger_1$. Following~\cite{sidechain} we denote by $\asmp_i$
with $i\in[n]$ the security assumption required by a ledger $\ledger_i$. That is, if the assumption holds then ledger is secure under the Definition~\ref{de:ledger}.
Formally, $\asmp_i$ is a sequence of events $\asmp_i[t]$ for each time slot $t$ that can assume value $1$, if the assumption is satisfied, and $0$ otherwise.

%Without loss of generality we assume that $\asmp_i$ are monotone in the sense that once violated, they cannot become true again. Formally, 
%$\asmp_i$ is a sequence of events $\asmp_i[t]$ for each time slot $t$ that satisfy $\neg \asmp_i[t] \rightarrow \neg \asmp_i[t+1]$ for all $t$.
There is an a priori unlimited number of (types of) assets, each asset representing e.g. a different cryptocurrency. We allow specific rules of behavior for each asset (called validity languages), and each asset behaves according to these rules on each of the ledgers where it is present.

Let $\ledger_1$ be the ledger that the parties are running with assumption $\asmp_1$. We consider a new ledger $\ledger_2$ with assumption $\asmp_2$.
In the model that we consider in this paper each party that is running $\ledger_1$ could receive the input $(\activate, \ledger_2)$. A party receiving this command starts the \emph{activation process}
in order to start running $\ledger_2$ (and maybe stop running $\ledger_1$). Let $t_P$ denote the time in which 
the party $P$ receives the activation command and let $\activep$ be the set of parties that received the activation command. Without loss of generality, let $P_1$ be the first party to receive the activation command (note that $t_{P_1}\leq t_{P_i}$ for all $P_i\in\activep$).
%We note that if a set of parties $\parties$ is such that the assumption $\asmp_2$ holds (e.g. if enough honest parties are willing to maintain $\ledger_2$), then $\ledger_2$ is
%secure.

%Let $t$ be the time at which one of the parties that is running $\ledger_1$ is activated. 
Informally, a secure activation process guarantees that if the number of parties that are willing to run $\ledger_2$ (i.e., the number of active parties)  
is such that $\asmp_2[t']=1$ for some $t'>t_{P_1}$, then at time $t'+\Delta_1$ the state of $\ledger_2$ corresponds to the state of $\ledger_1$ at time $t_{P_1}$ plus
a bounded $\Delta_2$. 
The above implies that $\ledger_2$ extends $\ledger_1$ and that $\ledger_2$ is secure (i.e. enjoys consistence and liveness).
In a nutshell, a secure activation process guarantees that the state of the old ledger is moved into the new ledger, and that the new ledger is secure.
We now give a more formal definition.

\begin{definition}[Activation Process]
 We say that an activation process with activation parameters $(\Delta_1,\Delta_2)$ (where $\Delta_1,\Delta_2\in\mathbb{N}$) is secure if the following condition is satisfied:

If $\activep$ is such that $\asmp_2[t]=1$ for all $t\in [t_{P_1}+\Delta_1, t_{P_1}+\Delta_2]$ %with $\Delta_1,\Delta_2\in\mathbb{N}$
	and $\asmp_1[t']=1$ for all $t' \leq t_{P_1}+\Delta_1$, then the state of $\ledger_2$ at some time $T\in [t_{P_1}+\Delta_1, t_{P_1}+\Delta_1+\Delta_2]$ is such that $\ledger^\star=\ledger_2$
	where $  P_i^{\ledger_1}[t_{P_i}] \preceq \ledger^\star$ for some $P_i\in\activep$.  
\end{definition}

%A commuting process is secure if there exists a time $t=$ where $\asmp_2[t]=1$ and the state of $\ledger_2$ at time $t$ is  $\ledger^\star=\ledger_2$ 	where $  %P_i^{\ledger_1}[t_{P_i}] \preceq \ledger^\star$ for some $P_i\in\activep$.

\subsection{The Adoption Threshold}

