\subsection{Ledger Consensus: Model}

\subsubsection{Model.}

In this section we define our notion of protocol execution following~\cite{DBLP:conf/eurocrypt/GarayKL15,DBLP:conf/focs/Canetti01}.
Programs involved in a protocol execution. The execution of a protocol $\Pi$ is driven by an
environment program $\env$ that may spawn multiple instances running the protocol $\Pi$. The programs
in question can be thought of as interactive Turing machines (ITM) that have communication,
input and output tapes. An instance of an ITM running a certain program will be referred to as
an interactive Turing machine instance or ITI. The spawning of new ITI's by an existing ITI as
well as the interaction between them is at the discretion of a control program which is also an ITM
and is denoted by $C$. The pair $(\env, C)$ is called a system of ITM's, cf.~\cite{DBLP:conf/focs/Canetti01}. 
Specifically, the execution driven by $\env$ is defined with respect to a protocol $\Pi$, an adversary $\adv$
(also an ITM) and a set of parties $P_1,\dots,P_n$; these are hardcoded in the control program $C$. 
Initially, the environment $\env$ is restricted by $C$ to spawn the adversary $\adv$. Each time the
adversary is activated, it may send one or more messages of the form $(\corrupt, P_i)$ to $C$. The control
program $C$ will register party $P_i$ as corrupted, only provided that the environment has previously
given an input of the form $(\corrupt, P_i)$ to $\adv$ and that the number of corrupted parties is less or
equal $\tcorrupt$, a bound that is also hardcoded in $C$. 

%The first ITI party to be spawned running protocol
%$\Pi$ is restricted by $C$ to be party $P_1$. After a party $P_i$ is activated, the environment is restricted to
%activate party $P_{i+1}$, except when $P_n$ is activated in which case the next ITI to be activated is always
%the adversary $\adv$. Note that when a corrupted party $Pi$ is activated the adversary $\adv$ is activated
%instead.



\subsubsection{Ledger Consensus.}
Ledger consensus (a.k.a. ``Nakamoto consensus'') is the problem where a set of servers
(or nodes) operate continuously accepting inputs
that are called transactions and incorporate them in a public data 
structure called the {\em ledger}. 
A ledger (denoted in calligraphic-face, e.g. $\ledger$) is a mechanism for maintaining a sequence of transactions, often
stored in the form of a blockchain (cf. appendix \ref{se:bcabstraction}). In this paper, we slightly abuse the language by letting $\ledger$ (without further
qualifiers) interchangeably refer to the algorithms used to maintain the sequence, and all the views of the
participants of the state of these algorithms when being executed. For example, the (existing) ledger Bitcoin
consists of the set of all transactions that ever took place in the Bitcoin network, the current UTXO set, as
well as the local views of all the participants.
In contrast, we call a ledger state a concrete sequence of transactions $\tx_1,\tx_2,\dots$ stored in the stable
part of a ledger $\ledger$, typically as viewed by a particular party. Hence, in every blockchain-based ledger $\ledger$,
every fixed chain $C$ defines a concrete ledger state by applying the interpretation rules given as a part of the
description of $\ledger$ %\nnote{shouldn't this be a calligraphic L?} 
(for example, the ledger state is obtained from the blockchain by dropping the last $k$ blocks
and serializing the transactions in the remaining blocks). We denote by $\ledger^P[t]$
the ledger state of a ledger $\ledger$ as viewed by a party $P$ at the beginning of a time slot $t$.
% and by $\hat P^\ledger[t]$ the complete state of the ledger (at time $t$) including all pending transactions that are not stable yet. 


For two ledger states (or, more generally, any sequences), we denote by $\preceq$ the prefix relation.
Recall the definition of secure ledger protocol given in~\cite{sok}.


\begin{definition}\label{de:ledger} A ledger protocol $\ledger$ is secure if it enjoys the following two properties.
\begin{itemize}

\item {\em Consistency:} This property mandates that if a client queries
an honest node's ledger at round $t_1$  
and receives the response $\mc{L}_1$, 
then a client querying an honest node's ledger at round $t_2\geq t_1 $
 receives a response $\mc{L}_2$ that satisfies $\mc{L}_1 \preceq \mc{L}_2$, 
where $\preceq$ denotes the standard prefix operation. 

\item {\em Liveness:} If a transaction $tx$ is given as input to all honest
nodes continuously for a certain number of rounds denoted by $u$, 
and a client queries any honest node's ledger
after these $u$ rounds, then the node responds with a value
$\mc{L}$ that includes $tx$.

\end{itemize}

\end{definition}


We consider a setting where a set of parties run a protocol maintaining a ledger $\ledger_1$. Following~\cite{sidechain} we denote by $\asmp_1$
the assumptions for $\ledger_1$.
 That is, if the assumption $\asmp_1$ holds then ledger $\ledger_1$ is secure under the Definition~\ref{de:ledger}.
Formally, $\asmp_i$ for a ledger $\ledger_i$ is a sequence of events $\asmp_i[t]$ for each time slot $t$ that can assume value $1$, 
if the assumption is satisfied, and $0$ otherwise.
For example, $\asmp_i$ may denote that
there has never been a majority of hashing power (or stake in a particular
asset, on this ledger or elsewhere) under the control of the adversary; that a
particular entity (in case of a centralized ledger) was not corrupted; and so
on.
Without loss of generality, we say that the assumption $\asmp_1$ for the ledger $\ledger_1$ holds if and only if the number of corrupted parties (the parties
that received the input $(\corrupt, \cdot)$) is below $\tcorrupt_1$ (where $\tcorrupt_1$ is part of the control function as described in the beginning 
of this section).


%Without loss of generality we assume that $\asmp_i$ are monotone in the sense that once violated, they cannot become true again. Formally, 
%$\asmp_i$ is a sequence of events $\asmp_i[t]$ for each time slot $t$ that satisfy $\neg \asmp_i[t] \rightarrow \neg \asmp_i[t+1]$ for all $t$.
There is an a priori unlimited number of (types of) assets, each asset representing e.g. a different cryptocurrency. We allow specific rules of behavior for each asset (called validity languages), and each asset behaves according to these rules on each of the ledgers where it is present.


\subsection{Defining Secure Activations}
Let $\ledger_1$ be the ledger that the parties are running with assumption $\asmp_1$. We now consider a new ledger $\ledger_2$ with assumption $\asmp_2$.
$\ledger_2$ represents un updated version of $\ledger_2$ (i.e., an improved protocol with respect to $\ledger_1$).
In the scenario that we are considering in this paper each party that is running $\ledger_1$ could receive the input $(\activate, \ledger_2)$. A party
that receives this command starts the \emph{update process}
in order to be prepared to run the code of $\ledger_2$ (and maybe stop running $\ledger_1$). Let $t_P$ denote the time in which 
the party $P$ receives the update command and let $\activep$ be the set of parties that received the update command. Without loss of generality, let $P_1$ be the first party to receive the update command (note that $t_{P_1}\leq t_{P_i}$ for all $P_i\in\activep$).
%We note that if a set of parties $\parties$ is such that the assumption $\asmp_2$ holds (e.g. if enough honest parties are willing to maintain $\ledger_2$), then $\ledger_2$ is
%secure.

%Let $t$ be the time at which one of the parties that is running $\ledger_1$ is activated. 
Informally, a secure activation process guarantees that if the set of honest parties that are willing to run $\ledger_2$ 
is such that $\asmp_2[t']=1$   (i.e., the number of corrupted parties is less
than $\tcorrupt_2$) for some $t'\geq t_{P_1}$, then
the state of $\ledger_2$ at some time $T>t'$ corresponds to the state of $\ledger_1$ at time $t_{P_i}$ with $P_i\in\activep$.

 
%\nnote{I think (I might be wrong) that, as it is right now, it is confusing what are the two time points that: a) $L_2$ becomes secure and b) $L_2$ includes the state of $L_1$. From the above text, the reader understands that these time points are $t'$ (where $t' > t_{P_1}$) and $t' + \Delta_1$ respectively. Is this what we want to say? This does not comply (I think) with the time points mentioned in Definition 2 below.}

%\nnote{Why dont we just say that: $L_2$ will become secure at time point $t_{P_1} + \Delta_1$  and will include $L_1$ at time point $t_{P_1} + \Delta_1 + \Delta_2$?}
%\mnote{I changed it a bit. What do you think now?}

%\nnote{Furthermore, I don't understand the phrase: "the state of $\ledger_2$ corresponds to the state of $\ledger_1$ at time $t_{P_1}$ plus a bounded $\Delta_2$". What about the state of $\ledger_1$ before that time point? It should still be included in $\ledger_2$, as a prefix. Right?}
%\mnote{Doesn't what I wrote implies that $\ledger_1$ is a prefix of $\ledger_2$?}

%\nknote{"at time $t_{p_i}$ with $p_i\in\activep$". Should this be "at time $t_{P_i}$ with $P_i\in\activep$"?} \mnote{Right, I have changed it}

\ignore{
\nknote{It looks good. Now the two time points (where $L_2$ becomes secure and $L_2$ includes $L_1$) are $t'$ and $T$ respectively. This is clear.}

\nknote{"corresponds to the state of $\ledger_1$ at time $t_{p_i}$ with $p_i\in\activep$"  Do we want to say "corresponds"? Does this imply equal to? Should we say "includes as a prefix"?}\mnote{I want to say that it is equal. If we say that $\ledger_1$ is just a prefix of $\ledger_2$ then $\ledger_2$ might contain wrong information. Instead, I want to
say that when $\ledger_2=\ledger_1$ $\asmp_2$ holds. This guarantees that $\ledger_2$ has $\ledger_1$ has a prefix at that from that moments it is secure. Does it make sense?}

\nknote{What is the timepoint when changes are actually activated? I.e., When does $L_2$ start to operate? I assume that it is, when we know that $L_2$ is secure, i.e., at time point $t_{P_1} + \Delta_1$. If so, then $L_2$ must include the state of $\ledger_1$ at time $t_{p_1} + \Delta_1$. In particular, it must include $ P_i^{\ledger_1}[t_{P_1} + \Delta_1] $ for some $P_i\in\activep$. What do you think? }\mnote{This makes sense, but would make the security definition stronger (i.e., harder to achieve).
Let's first see what we can achieve with our protocol and later change the definition if what we have is better than what I expect.}
}

The above implies that $\ledger_2$ extends $\ledger_1$ and that $\ledger_2$ is secure (i.e. enjoys consistence and liveness).
In a nutshell, a secure update process guarantees that the state of the old ledger is moved into the new ledger, and that the new ledger is secure.
We now give a more formal definition.

\begin{definition}[Activation Process]
 We say that an activation process with activation parameters $(\Delta_1,\Delta_2)$ (where $\Delta_1,\Delta_2\in\mathbb{N}$) is secure if the following condition is satisfied:

If $\asmp_2[t]=1$ for all $t\geq t_{P_1}+\Delta_1$ %with $\Delta_1,\Delta_2\in\mathbb{N}$
and $\asmp_1[t']=1$ for all $t' \leq t_{P_1}+\Delta_1+\Delta_2$, then the state of $\ledger_2$ at some time $T\in [t_{P_1}+\Delta_1, t_{P_1}+\Delta_1+\Delta_2]$ is such that $\ledger^\star=\ledger_2$ where $  \ledger_1^{P_i}[t_{P_i}] \preceq \ledger^\star$ for some $P_i\in\activep$.  

 
\end{definition}


