\section{Ledger Enhancements}

\subsection*{Recording the History of Updates}
We use the ledger as the single version of the truth for software updates. To this end, we enhance the ledger with new types of events to be permanently recorded in the immutable history of updates. An update starts its life with the issuance of an \emph{Update Proposal} by a stakeholder. This proposal must achieve the consensus of the majority of stake, through a voting mechanism, in order to become adopted. In this section, we will follow the course of an Update Proposal through out its full lifecycle.

\todo{Nikos: What events will be stored 
as transactions in the ledger? 
Candidates are: Update Proposals, Votes ,Delegations ,Activations}

\subsection*{Update Proposals}
An Update Proposal can be issued by any party that owns stake. The party first creates the Update Proposal, hashes it, and uploads it to a decentralized storage service (to be discussed in later sections). Subsequently, they place the Update Proposal on the Blockchain.

We introduce a new type of transaction, an \emph{Update Issuance Commit Transaction (UICT)}, which commits the Update Proposal to the blockchain. Since it is a transaction it will be included into a block and thus into the ledger. The UICT contains the following data:

\begin{itemize}
\item[\textbf{commit:}] A salted commitment to the Update Proposal hash as well as the public saking key of the issuer. 
\begin{verbatim}
commit = H(salt || pk || H(Update Proposal))
\end{verbatim}
\item[\textbf{pk:}] The public key of the Update Proposal issuer.
\item[\textbf{sig:}] A signature on commit by the Update Proposal issuer public key pk
\end{itemize}

A UICT is broadcast to the network by the issuer. Upon receiving the UICT, the validators ensure that the signature sig verifies on the plaintext commit with public key pk and that the signing staking key pk satisfies a configurable minimum threshold of stake prior to relaying it or including it in their block. While relaying and inclusion is conditioned on threshold, if a UICT is included in a block generated by another miner, the block and UICT are accepted as valid regardless of stake. If a new UICT is broadcast pertaining to the same commitment and pk, it is rejected.

Once the UICT has been stabilized (by being buried under k blocks), the Update Issuer issues an \emph{Update Issuance Reveal Transaction (UIRT)}, which reveals the Update Proposal hash to the blockchain and makes it available for download. The UIRT contains the following data:

\begin{itemize}
\item[\textbf{proposal:}] 
The hash of the Update Proposal, 
i.e., %\verb|H(Update Proposal)|. 
\begin{verbatim}
H(Update Proposal).
\end{verbatim}
\item[\textbf{salt:}] The salt previously used in the UICT.
\item[\textbf{pk:}] The public key of the Update Proposal issuer.
\end{itemize}

Upon receiving a UIRT, any validator ensures that a respective UICT has been included in the most recent 12k blocks. On the one hand, this number has to be large enough to allow for block stability and liveness. On the other hand, it must be small enough so that unclaimed UIRTs can expire and garbage collected to avoid UTXO pollution; in addition, it must be small enough to bound the stake-shift that could have occured from UICT issuance to UIRT issuance. The validator finds the respective UICT by calculating 
\verb;commit = H(salt || pk || H(Update Proposal));  based on the data provided in the UIRT and looks for the commit value in the most recent 12k blocks. Furthermore, the validator ensures the pk in the UIRT matches the previously claimed pk in the UICT as well as within the UICT commit value.

The reason why the Update Proposal is issued on the blockchain in two stages, with UICT first and UIRT later, is so that the rightful author can claim authorship of a particular Update Proposal. If the Update Proposal hash were to be revealed immediately, a dishonest party could create a competing transaction, signing the same proposal with their own key to claim authorship. This follows a similar model to Namecoin name claims \cite{Namecoin}. If multiple valid UIRTs pertaining to the same commitment are received, only the first is included in the blockchain. Only the first such transaction is necessary, as any two UIRTs will necessary contain the same data due to it having been committed in the UICT and by the collision resistance property of the underlying hash function.

The slot at which the UIRT of an Update Proposal has been included is referred to as the \emph{issuance-time} of the proposal. After a UIRT transaction is validated, the node automatically attempts to download the Update Proposal, by hash, from the Decentralized Storage service. The node hashes the downloaded content to ensure that the hash included in the blockchain matches the hash of the downloaded content.

\subsection*{Update Proposal Validation}
\todo{Nikos: We need to define the rules for a legitimate Update Proposal}
For example, a legitimate Update Proposal cannot have a dependency with an Update Proposal who has not been activated yet. So the version requirement of an Update Proposal must be the current adopted version.
\begin{verbatim}
sw_version_from == current_sw_version 
&&
prot_version_from == current_prot_version
\end{verbatim}

\todo{Nikos: Just validating an Update Proposal when it is revealed is not enough. It has to remain valid also right before activation}

\subsection*{Update Proposal Lifecycle}
\todo{Nikos: We need a state diagram of the various states in the life of an update proposal. What are the valid states?}
